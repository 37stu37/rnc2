# -*- coding: utf-8 -*-
"""temporal_network_try.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kptG5xUQkG2GChLgAI7TaMBj2ulwl_lu
"""

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
import sys
import os
from pathlib import Path
import networkx as nx
from numba import jit

"""
**Tentative code for rnc2 temporal network**

* the idea is to set a maximaly connected network from the start
* the network is an adjacency list where we add a third column as a "contact time" list
* contact times represent the set of active connections at a certain time
* static network evolve through time by filtering by the acitve connection at every time step

** Test with FFE edge list **

"""

#%%
data_folder = Path("/Users/alex/Google Drive/04_Cloud/01_Work/Academia/01_Publications/00_Alex/005_RNC2/data")

edge = data_folder / 'Copy of edge_data.parquet'
wind = data_folder / 'Copy of GD_wind.csv '

edges = pd.read_parquet(edge, engine='pyarrow')

#%%

# wind characteristics (wind_bearing_max, wind_bearing_min, distance)
@jit
def wind_scenario(file_name):
    # wind scenario conditions
    wind_data = pd.read_csv(file_name)
    i = np.random.randint(0, wind_data.shape[0])
    w = wind_data.iloc[i, 2]
    distance = wind_data.iloc[i, 1]
    b = wind_data.iloc[i, 3]
    # wind direction
    wind_bearing_max = b + 45
    wind_bearing_min = b - 45
    if b == 360:
        wind_bearing_max = 45
    if b <= 0:  # should not be necessary
        wind_bearing_min = 0
    if b == 999:
        wind_bearing_max = 999
        wind_bearing_min = 0
    return wind_bearing_max, wind_bearing_min, distance
    
    return wind_bearing_max, wind_bearing_min, d

# display edge list as network
def display_network(edge_list_dataframe):
    graph = nx.from_pandas_edgelist(edge_list_dataframe, edge_attr=True)
    options = {'node_color': 'red', 'node_size': 50, 'width': 1, 'alpha': 0.4,
               'with_labels': False, 'font_weight': 'bold'}
    nx.draw_kamada_kawai(graph, **options)
    plt.show()
    return graph

# create contact array on the same index as edge list
@jit
def create_contact_array(e):
    return np.full((e.values.shape[0],1), True)

# conditions, return a boolean
@jit
def initial_conditions(e):
    rng = np.random.uniform(0, 1, size=e.values.shape[0])
    boolean = rng < e.IgnProb_bl.values


# update a new contact time column (for time = 1 here)
@jit
def update_contacts(contact_array, boolean_array):
    return np.c_[contact_array, boolean_array]
    
# new edges list at time
@jit
def filter_edgelist(e, contact_array):
    return e.values[contacts[:, time] == True]

    
    
    