# -*- coding: utf-8 -*-
"""temporal_network_try.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/37stu37/rnc2/blob/master/temporal_network_try.ipynb
"""

# from google.colab import drive
# drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
# import dask.dataframe as dd
# import dask.array as da
# import sys
# import os
from pathlib import Path
# import networkx as nx
from numba import jit
from numba import njit
# from dask.distributed import Client
pd.options.mode.chained_assignment = None  # default='warn'

from IPython import get_ipython
get_ipython().magic('time')
get_ipython().magic('timeit')

# client = Client(processes=False)
# client

#%%
# import data
folder = Path('/Users/alex/Google Drive/04_Cloud/01_Work/Academia/01_Publications/00_Alex/005_RNC2')
edge_file = folder / 'data' / 'Copy of edge_data.parquet'
wind_file = folder / 'data' / 'Copy of GD_wind.csv'

wind_data = pd.read_csv(wind_file) 
edgelist = pd.read_parquet(edge_file, engine='pyarrow')

#%%
def wind_scenario(wind_data):
    i = np.random.randint(0, wind_data.values.shape[0])
    w = wind_data.values[i, 2]
    dist = wind_data.values[i, 1]
    b = wind_data.values[i, 3]
    bear_max = b + 45  # wind direction
    bear_min = b - 45
    if b == 360:
        bear_max = 45
    if b <= 0:  # should not be necessary
        bear_min = 0
    if b == 999:
        bear_max = 999
        bear_min = 0
    return bear_max, bear_min, dist # wind characteristics, bearing and distance


def Active_Edges(mask,s,t,edges=edgelist):
    ActiveEdges = edgelist[mask]
    ActiveEdges["scenario"] = s
    ActiveEdges["time"] = t
    return ActiveEdges


def mask_ignition(edges=edgelist):
    rng = np.random.uniform(0, 1, size=edges.values.shape[0])
    return (rng < edgelist.IgnProb_bl.values)*1


def mask_propagation(mask,edges=edgelist):
    previousTarget = edgelist.target[mask]
    return np.in1d(edgelist.source.values, previousTarget.values)


def mask_wind(w_b_max, w_b_min, w_dist):
    return (edgelist.bearing.values < w_b_max) & (edgelist.bearing.values > w_b_min) & (edgelist.distance.values < w_dist)


def mask_previously_activated(time_matrix):
    previouslyActivated = time_matrix.iloc[:, :-1].sum(axis=1)
    return np.where(previouslyActivated> 0, 0, 1) # previouslyActivated > 0 means Yes, activated and the result of the mask is 0 or False !


def mask_prior_activation(time_matrix):
    return time_matrix.iloc[:, -1] == 1

# %%timeit
def main(n, edgelist=edgelist):
    for scenario in range(n):
        # initial setup
        condition = True
        list_of_Activations = []
        time = 0
        # wind conditions
        w_bearing_max, w_bearing_min, w_distance = wind_scenario(wind_data)
        # ignition
        maskIgnition = mask_ignition()
        CoTime = pd.DataFrame (maskIgnition, columns=['initial_state'])
        print("number of ignitions : {}".format(len(CoTime[CoTime.initial_state == 1])))
        # add scenario and time to active edges
        ActiveEdges = Active_Edges(CoTime['initial_state'] == 1, scenario, time)
        list_of_Activations.append(ActiveEdges)
        
        while condition:
            print("scenario : {} time : {}".format(scenario, time))
            
            # propagation mask
            maskPreviousEdge = mask_prior_activation(CoTime)
            maskSource = mask_propagation(maskPreviousEdge)
            
            # wind mask
            maskWind = mask_wind(w_bearing_max, w_bearing_min, w_distance)
            
            # burnt mask
            maskBurnt = mask_previously_activated(CoTime)
            
            # store mask in CoTime matrix
            maskMerge = (maskSource) & (maskWind) & (maskBurnt)
            CoTime['time{}'.format(time)] = maskMerge
            
            # Active edges at this time
            ActiveEdges = Active_Edges(CoTime['time{}'.format(time)] == 1, scenario, time)
            list_of_Activations.append(ActiveEdges)
            
            # break while condition if no more fires
            fires = (CoTime['time{}'.format(time)] == 1).sum(axis=0)
            condition = fires != 0
            
            # advance time
            time += 1
            
        # if while loop broken, save activation for the scenario
        Activations = pd.concat(list_of_Activations)
        Activations.to_parquet(folder / 'output' / 'scenario{}_Activations.parquet'.format(scenario), engine='pyarrow')
        
#%%
%%time
main(1)
