# -*- coding: utf-8 -*-
"""temporal_network_try.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kptG5xUQkG2GChLgAI7TaMBj2ulwl_lu
"""

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
import sys
import os
from pathlib import Path
import networkx as nx
from numba import jit

"""
**Tentative code for rnc2 temporal network**

* the idea is to set a maximaly connected network from the start
* the network is an adjacency list where we add a third column as a "contact time" list
* contact times represent the set of active connections at a certain time
* static network evolve through time by filtering by the acitve connection at every time step

** Test with FFE edge list **

"""

#%%
data_folder = Path("/Users/alex/Google Drive/04_Cloud/01_Work/Academia/01_Publications/00_Alex/005_RNC2/data/")

edge = data_folder / 'Copy of edge_data.parquet'
wind = data_folder / 'Copy of GD_wind.csv '

edges = pd.read_parquet(edge, engine='pyarrow')

#%%

# wind characteristics (wind_bearing_max, wind_bearing_min, distance)
def wind_scenario(file_name):
    # wind scenario conditions
    wind_data = pd.read_csv(wind)
    i = np.random.randint(0, wind_data.shape[0])
    w = wind_data.iloc[i, 2]
    d = wind_data.iloc[i, 1]
    b = wind_data.iloc[i, 3]
    # wind direction
    wind_bearing_max = b + 45
    wind_bearing_min = b - 45
    if b == 360:
        wind_bearing_max = 45
    if b <= 0:  # should not be necessary
        wind_bearing_min = 0
    if b == 999:
        wind_bearing_max = 999
        wind_bearing_min = 0
    
    return wind_bearing_max, wind_bearing_min, d

# display edge list as network
def display_network(edge_list_dataframe):
    graph = nx.from_pandas_edgelist(edge_list_dataframe, edge_attr=True)
    options = {'node_color': 'red', 'node_size': 50, 'width': 1, 'alpha': 0.4,
               'with_labels': False, 'font_weight': 'bold'}
    nx.draw_kamada_kawai(graph, **options)
    plt.show()
    return graph
#%%
# create contact array on the same index as edge list
contacts = np.zeros((edges.values.shape[0],1))

# Set initial conditions and active edges at t = 0
def initial_edges_activation(edges):
    # random value for each edges
    rng = np.random.uniform(0, 1, size=edges.values.shape[0])
    # updating contacts at t=1 by comparing probability with RNG for each of the edges
    initiated_edges = np.where(rng < edges.IgnProb_bl.values)
    boolean = rng < edges.IgnProb_bl.values
    # column t=1 based on the initiated edges, 0 = inactive, 1 = active
    contacts = np.c_[contacts, np.zeros(contacts.shape[0])]
    
    edges = edges[boolean]
    
    
    
    