# -*- coding: utf-8 -*-
"""temporal_network_try.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/37stu37/rnc2/blob/master/temporal_network_try.ipynb
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
import dask.dataframe as dd
import dask.array as da
import sys
import os
from pathlib import Path
import networkx as nx
from numba import jit
from dask.distributed import Client
pd.options.mode.chained_assignment = None  # default='warn'

client = Client(processes=False)
client

"""---


**Tentative code for rnc2 temporal network**

@time

Conditions -> Boolean mask -> Contacts -> Edgelist


---
"""

# import data
folder = Path('/content/drive/My Drive/04_Cloud/01_Work/Academia/01_Publications/00_Alex/005_RNC2')
edge_file = folder / 'data' / 'Copy of edge_data.parquet'
wind_file = folder / 'data' / 'Copy of GD_wind.csv'

wind_data = pd.read_csv(wind_file) 
edgelist = pd.read_parquet(edge_file, engine='pyarrow')

"""**Conditions**


---

**Main**


---
"""

def wind_scenario(t, wind_data):
    if t == 0:
      i = np.random.randint(0, wind_data.values.shape[0])
      w = wind_data.values[i, 2]
      dist = wind_data.values[i, 1]
      b = wind_data.values[i, 3]
      bear_max = b + 45  # wind direction
      bear_min = b - 45
      if b == 360:
          bear_max = 45
      if b <= 0:  # should not be necessary
          bear_min = 0
      if b == 999:
          bear_max = 999
          bear_min = 0
      return bear_max, bear_min, dist # wind characteristics, bearing and distance
    else:
      return

def wind_mask(e, w_bearing_max, w_bearing_min, w_distance):
    mask1 = (e.bearing.values < w_bearing_max) & (e.bearing.values > w_bearing_min)
    mask2 = e.distance.values < w_distance
    mask = mask1 & mask2
    return mask

def ignition_mask(t, e, c):
    # initial ignition
    if t == 0:
      rng = np.random.uniform(0, 1, size=e.values.shape[0])
      mask = rng < e.IgnProb_bl.values
      return mask
    else:
    # propagation
      mask_previous_time = c.iloc[:, t-1] == 1
      previousTarget = e.target.iloc[mask_previous_time.values]
      mask = np.in1d(e.source.values, previousTarget.values)
      return mask

def not_burnt_mask(t, e, c):
    if t > 1:
      previouslyActivated = c.iloc[:,:t-1]
      previouslyActivated_sum = previouslyActivated.sum(axis=1)
      mask = np.where(previouslyActivated_sum> 0, 1, 0)
      mask = mask != 1
    else:
      mask = c.iloc[:,0].values
      mask = mask !=1
    return mask

n=10
for scenario in range(n):
    condition = True
    list_of_Activations = []
    time = 0 
    bear_max, bear_min, distance = wind_scenario(time, wind_data)
    CoTime = pd.DataFrame() # CoTime = pd.DataFrame(np.ones((len(edgelist), 1)))
    while condition = True:
        print("scenario : {} time : {}".format(scenario, time))
        # ignititon and propagation
        ignition_m = ignition_mask(time, edgelist, CoTime)
        if time == 0:
          CoTime.iloc[:,0] = mask
        # targets under the wind
        wind_m = wind_mask(edgelist, bear_max, bear_min, distance)
        # not already burnt
        not_burnt_m = not_burnt_mask(time, edgelist, CoTime)
        # resulting mask
        mask = (ignition_m & wind_m & not_burnt_m)
        # add mask to CoTime
        if time > 0:
          CoTime = pd.DataFrame(np.c_[CoTime, mask*1])
        # create Active edges
        ActiveEdges = edgelist[mask]
        if ActiveEdges is empty:

        print("number of active edges : {}".format(len(ActiveEdges)))
        # add scenario and time to active edges
        ActiveEdges["scenario"] = scenario
        ActiveEdges["time"] = time
        # append to list
        list_of_Activations.append(ActiveEdges)
        time += 1
    Activations = pd.concat(list_of_Activations)
    Activations.to_parquet(folder / 'output' / 'scenario{}_Activations.parquet'.format(scenario), engine='pyarrow')