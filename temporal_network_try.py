# -*- coding: utf-8 -*-
"""temporal_network_try.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/37stu37/rnc2/blob/master/temporal_network_try.ipynb
"""

# from google.colab import drive
# drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
import dask.dataframe as dd
import dask.array as da
import sys
import os
from pathlib import Path
import networkx as nx
from numba import jit
from dask.distributed import Client
pd.options.mode.chained_assignment = None  # default='warn'

client = Client(processes=False)
client

#%%
# import data
folder = Path('/Users/alex/Google Drive/04_Cloud/01_Work/Academia/01_Publications/00_Alex/005_RNC2')
edge_file = folder / 'data' / 'Copy of edge_data.parquet'
wind_file = folder / 'data' / 'Copy of GD_wind.csv'

wind_data = pd.read_csv(wind_file) 
edgelist = pd.read_parquet(edge_file, engine='pyarrow')

#%%

def wind_scenario(t, wind_data):
    if t == 0:
      i = np.random.randint(0, wind_data.values.shape[0])
      w = wind_data.values[i, 2]
      dist = wind_data.values[i, 1]
      b = wind_data.values[i, 3]
      bear_max = b + 45  # wind direction
      bear_min = b - 45
      if b == 360:
          bear_max = 45
      if b <= 0:  # should not be necessary
          bear_min = 0
      if b == 999:
          bear_max = 999
          bear_min = 0
      return bear_max, bear_min, dist # wind characteristics, bearing and distance
    else:
      return

def wind_mask(e, w_bearing_max, w_bearing_min, w_distance):
    mask1 = (e.bearing.values < w_bearing_max) & (e.bearing.values > w_bearing_min)
    mask2 = e.distance.values < w_distance
    mask = mask1 & mask2
    return mask

def ignition_mask(t, e, c):
    # initial ignition
    if t == 0:
      rng = np.random.uniform(0, 1, size=e.values.shape[0])
      mask = rng < e.IgnProb_bl.values
      return mask
    else:
    # propagation
      mask_previous_time = c.iloc[:, t-1] == 1
      previousTarget = e.target.iloc[mask_previous_time.values]
      mask = np.in1d(e.source.values, previousTarget.values)
      return mask

def not_burnt_mask(t, e, c):
    if t > 1:
      previouslyActivated = c.iloc[:,:t-1]
      previouslyActivated_sum = previouslyActivated.sum(axis=1)
      mask = np.where(previouslyActivated_sum> 0, 1, 0)
      mask = mask != 1
    else:
      mask = c.iloc[:,0].values
      mask = mask !=1
    return mask

#%%
n=2
for scenario in range(n):
    # initial setup
    condition = True
    list_of_Activations = []
    time = 0 
    print("scenario : {} time : {}".format(scenario, time))
    # wind conditions
    bear_max, bear_min, distance = wind_scenario(time, wind_data)
    # ignition
    rng = np.random.uniform(0, 1, size=edgelist.values.shape[0])
    CoTime = pd.DataFrame ((rng < edgelist.IgnProb_bl.values)*1, columns=['time{}'.format(time)])
    print("number of ignitions : {}".format(len(CoTime[CoTime.time0 == 1])))
    # add scenario and time to active edges
    ActiveEdges = edgelist[CoTime['time{}'.format(time)] == 1]
    ActiveEdges["scenario"] = scenario
    ActiveEdges["time"] = time
    list_of_Activations.append(ActiveEdges)
    
    while condition:
        time += 1
        print("scenario : {} time : {}".format(scenario, time))
        # propagation mask
        previousTarget = CoTime['time{}'.format(time-1)] == 1
        newSource = ActiveEdges.source[previousTarget]
        maskSource = np.in1d(edgelist, newSource)
        # wind mask
        maskWind = (edgelist.bearing.values < w_bearing_max) &
        (edgelist.bearing.values > w_bearing_min) & 
        (edgelist.distance.values < w_distance)
        # burnt mask
        previouslyActivated = CoTime.drop('time{}'.format(time),
                                          axis=1).sum(axis=1)
        maskBurnt = np.where(previouslyActivated> 0, 0, 1) # burnt == 0 ==> False
        
        # store mask in CoTime matrix
        maskMerge = (maskSource) & (maskWind) & (maskBurnt)
        CoTime['time{}'.format(time)] = maskMerge
        
        # Active edges at this time
        ActiveEdges = edgelist[CoTime['time{}'.format(time)] == 1]
        ActiveEdges["scenario"] = scenario
        ActiveEdges["time"] = time
        list_of_Activations.append(ActiveEdges)
        
        # break while condition if no more fires
        fires = (CoTime['time{}'.format(time)] == 1).sum(axis=0)
        condition = fires != 0
        print("condition {} at time {}".format(condition, time))
        
    # if while loop broken, save activation for the scenario
    Activations = pd.concat(list_of_Activations)
    Activations.to_parquet(folder / 'output' / 
                           'scenario{}_Activations.parquet'.format(scenario), 
                           engine='pyarrow')