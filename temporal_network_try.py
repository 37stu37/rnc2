# -*- coding: utf-8 -*-
"""temporal_network_try.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/37stu37/rnc2/blob/master/temporal_network_try.ipynb
"""

# from google.colab import drive
# drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
import dask.dataframe as dd
import dask.array as da
import sys
import os
from pathlib import Path
import networkx as nx
from numba import jit
from dask.distributed import Client

client = Client(processes=False)
client

"""---


**Tentative code for rnc2 temporal network**

@time

Conditions -> Boolean mask -> Contacts -> Edgelist


---
"""

# import data
folder = Path('/Users/alex/Google Drive/04_Cloud/01_Work/Academia/01_Publications/00_Alex/005_RNC2')
edge_file = folder / 'data' / 'Copy of edge_data.parquet'
wind_file = folder / 'data' / 'Copy of GD_wind.csv'

edgelist = pd.read_parquet(edge_file, engine='pyarrow')

# %%

"""**Conditions**


---
"""

def wind_scenario(file_name): 
    wind_data = pd.read_csv(file_name) 
    i = np.random.randint(0, wind_data.shape[0])
    w = wind_data.iloc[i, 2]
    dist = wind_data.iloc[i, 1]
    b = wind_data.iloc[i, 3]
    bear_max = b + 45  # wind direction
    bear_min = b - 45
    if b == 360:
        bear_max = 45
    if b <= 0:  # should not be necessary
        bear_min = 0
    if b == 999:
        bear_max = 999
        bear_min = 0
    return bear_max, bear_min, dist # wind characteristics, bearing and distance

def condition0(t, e, c):
    # ignition ?
    rng = np.random.uniform(0, 1, size=e.values.shape[0])
    return rng < e.IgnProb_bl.values

def condition1(t, e, c):
    # is this edge.target a new edge.source ?
    previous_target = e.target.values[c[:, t-1] == True]
    return np.in1d(e.target.values, previous_target)

def condition2(t, e, c, w_bear_max, w_bear_min):
    # wind direction
    return (e.bearing.values < w_bear_max) & (e.bearing.values > w_bear_min)

def condition3(t, e, c, w_dist):
    # wind speed
    return e.distance.values < w_dist

def condition4(t, e, c):
      # already burnt in previous fires
      return np.any(c[:, :-1] == True, axis=1)

#%%
"""**Main**


---
"""

for scenario in range(1):
  time = 0
  list_of_activation = [] # to record fires
  
  while True in contact_matrix[:,-1]:  # while still some fires burning
        print("scenario : {}".format(scenario))
        print("time step : {}".format(time))
        
        if time = 0:
              contact_matrix = np.full((edgelist.shape[0],1), True) # keep track of contacts in time
              wind_bearing_max, wind_bearing_min, wind_distance = wind_scenario(wind_file) # wind conditions for each scenarios
              ignitions = condition0  # initial ignitions
              contact_matrix[:, time] = ignitions
        else:
              propagation = condition1(time,edgelist,contact_matrix) & \ #target -> source
                    condition2(time,edgelist,contact_matrix,wind_bearing_max, wind_bearing_min) & \ # wind
                    condition3(time,edgelist,contact_matrix,wind_distance) & \ # wind distance
                    condition4(time,edgelist,contact_matrix)  # not already burnt
                    
      # update contact matrix with new time activation
      contact_matrix = np.c_[contact_matrix, propagation]
      print("fire still burning ? \n {}".format(True in contact_matrix[:, -1]))
      # active edges at time
      active_edges = edgelist.values[contact_matrix[:, time] == True]
      active_edges['scenario'] = scenario
      active_edges['time'] = time
      # record acrive edges to list
      list_of_activation.append(active_edges)
      time += 1
  else:
      # record active edges in dask and export to parquet
      da_scenario = da.concatenate(list_of_activation, axis=1)
  # at the end of scenario, save activations to parquet
  dd_scenario = dd.from_dask_array(da_scenario, columns=['source', 'target', 'distance', 'bearing', 'IgnProb_bl', 'scenario', 'time'])
  dd_scenario['scenario'] = scenario
  dd_scenario.to_parquet(os.path.join(folder / 'output' /'scenario_{}.parquet'.format(scenario)))

